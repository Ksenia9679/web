<!DOCTYPE html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <link href="../stati/stati.css" rel="stylesheet"> 
    <link rel="preconnect" href="https://fonts.googleapis.com"> 
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@600&display=swap" rel="stylesheet"> 
    <script src="" defer></script> 
    <title>InfoTrends</title> 
</head> 
<body> 
    <header>
        <div class="container">
            <div class="logo-container">
                <img src="../img/logotype.png" alt="логотип">
                    <h1 class="title">
                        InfoTrends  
                    </h1>
            </div>
        </div>
    </header>
<main>
    <ul>
        <li>
            <a href="../stati/stati.html" data-text="Статьи">
                Статьи
            </a>
        </li>
        <li>
            <a href="../news/news.html" data-text="Новости">
                Новости
            </a>
        </li>
        <li>
            <a href="../index.html" data-text="Главная">
                Главная
            </a>
        </li>
        <li>
            <a href="../contacts/contacts.html" data-text="Контакты">
                Контакты
            </a>
        </li>
        <li>
            <a href="../company/company.html" data-text=" компании">
                О компании
            </a>
        </li>
    </ul>
</main>
<div id="slideshow-wrap">
    <input type="radio" id="button-1" name="controls" checked="checked"/>
        <label for="button-1">
        </label>
    <input type="radio" id="button-2" name="controls"/>
        <label for="button-2">
        </label>
    <input type="radio" id="button-3" name="controls"/>
        <label for="button-3">
        </label>
            <label for="button-1" class="arrows" id="arrow-1">
                >
            </label>
            <label for="button-2" class="arrows" id="arrow-2">
                >
            </label>
            <label for="button-3" class="arrows" id="arrow-3">
                >
            </label>
    <div id="slideshow-inner">
        <ul>
            <li id="slide1">
                <img src="../img/js1.png">
                <div class="description">
                    <input type="checkbox" id="show-description-1"/>
                    <label for="show-description-1" class="show-description-label">Подробнее</label>
                    <div class="description-text">
                        <p class="vrcht">
                            Время чтения статьи: 4 минуты
                        </p>
                            <br>
                        <h2>
                            TypeScript: infer и conditional types. Продвинутый TS на примерах
                        </h2>
                            <br>
                        <p>
                            Разбираемся, что же такое conditional types и как написать свои утилиты, такие как ReturnType, InstanceType, 
                            NonNullable и др., при помощи ключевых слов infer и extends.
                                <br>
                                <br>
                            Продолжаем погружаться в продвинутый TypeScript. В этой статье рассмотрим conditional types, посмотрим на 
                            реализацию с примерами, узнаем какую роль играют ключевые слова extends и infer.
                            <br>
                            <br>
                            Статья предназначена для тех, кто хочет научиться уверенно пользоваться инструментом. Навыки помогут 
                            типизировать вам более сложные объекты в разработке крупных проектов.
                        </p>
                            <br>
                        <h1>
                            Conditional types 
                        </h1>
                            <br>
                        <p>
                            Conditional types или же "условные типы" позволяют определять типы в зависимости от условия. Если коротко, то это тернарный условный оператор, 
                            применяемый на уровне типа, а не на уровне значения. Принцип работы абсолютно такой же, как и в работе с переменными.
                                <br>
                                <br>
                            <strong>Условие ?</strong> Выполняем, если условие <strong>true </strong>: Выполняем, если условие <strong>false</strong>
                                <br>
                        <p>
                            type TypeA = { id: string }
                                <br>
                            type TypeB = { id: number }
                                <br>
                                <br>
                            type ConditionalType<T> = T extends TypeA ? TypeA : never
                                <br>
                                <br>
                            type ResultType1 = ConditionalType<TypeA> // TypeA
                                <br>
                            type ResultType2 = ConditionalType<TypeB> // never
                                <br>
                            Так же, как и при работе со значениями, а не типами, вы можете вызывать тернарные операторы по цепочке, тем самым расширив возможности условных типов.
                                <br>
                                <br>
                            <strong>Условие </strong> ? Если <strong>true</strong> : <strong>Условие</strong> ? Если <strong>true</strong> : Если <strong>false</strong>
                                <br>
                                <br>
                            type TypeA = { id: string }
                            type TypeB = { id: number }
                                <br>
                                <br>
                            type ConditionalType<T> = T extends TypeA ? TypeA : T extends TypeB ? TypeB : never
                                <br>
                                <br>
                            type ResultType1 = ConditionalType<TypeA> // TypeA
                                <br>
                            type ResultType2 = ConditionalType<TypeB> // TypeB
                                <br>
                            type ResultType3 = ConditionalType<string> // never
                                <br>
                            Если вам сложно воспринимать примеры на уровне типов, советую поработать в тернарными операторами в песочнице на уровне значений.
                                <br>
                                <br>
                            Вы могли заметить, что мы используем ключевое слово extends. Как оно работает ?
                                <br>
                                <br>
                            Extends проверяет, расширяет ли тип T другой данный тип TypeA, другими словами, мы убеждаемся, что значение типа T так же имеет тип TypeA.
                                <br>
                                <br>
                            Вы можете использовать conditional types для безопасности. Приведу пример:
                                <br>
                            type TypeA = { id: string }
                                <br>
                            type TypeB = { id: number }
                                <br>
                                <br>
                            type SafeType<T extends TypeA> = T['id']
                                <br>
                                <br>
                            type ResultType1 = SafeType<TypeA> // string
                                <br>
                            type ResultType2 = SafeType<TypeB> // ERROR: Type 'TypeB' does not satisfy the constraint 'TypeA'.
                                <br>
                                <br>
                            Такие типы называют constraints types или же "ограничивающие типы". Для этого вида типов можно придумать много применений, например, в связке 
                            с typeof мы можем обезопасить себя при разработке от невалидных данных, которые могут попасть в наши методы.
                                <br>
                                <br>
                        </p>
                        <h1>
                            ReturnType
                        </h1>
                            <br>
                        <p>
                            Перед нами открываются большие возможности в типизации нашего проекта.
                            Рассмотрим еще один пример, где мы реализуем кастомный ReturnType:
                                <br>
                                <br>
                            type CustomReturnType<T> = T extends (...args: any[]) => infer P ? P : any
                                <br>
                                <br>
                            type ResultType1 = CustomReturnType<() => void> // void
                                <br>
                            type ResultType3 = CustomReturnType<() => number> // number
                                <br>
                            Рассмотрим примеры поинтереснее:
                                <br>
                                <br>
                        </p>
                        <h1>
                            ArrayType
                        </h1>
                            <br>
                        <p>
                            В данном примере мы возвращаем union тип из содержимого массива.
                                <br>
                                <br>
                            type ArrayType<T> = T extends (infer Item)[] ? Item : T
                                <br>
                                <br>
                            const arr = [1, '2', null, undefined]
                                <br>
                                <br>
                            type ResultType = ArrayType<typeof arr> // string | number | null | undefined
                                <br>
                                <br>
                        </p>
                        <h1>
                            FirstArgType
                        </h1>
                            <br>
                        <p>
                            В данном примере мы возвращаем тип первого аргумента функции. Подобное мы можем сделать и со вторым и с третьим аргументом, или же со списком 
                            аргументов.
                                <br>
                                <br>
                            type CustomType<T> = T extends (id: infer ID, ...args: any[]) => unknown ? ID : never
                                <br>
                                <br>
                            type ResultType1 = CustomType<(id: string) => void> // string
                                <br>
                            type ResultType3 = CustomType<(id: number) => void> // number
                                <br>
                        </p>
                        <h1>
                            CustomInstanceType
                        </h1>
                            <br>
                        <p>
                            Напишем кастомную реализацию InstanceType из TS.
                                <br>
                                <br>
                            type CustomInstanceType<T> = T extends new (...args: any[]) => infer P ? P : any
                                <br>
                                <br>
                            interface ConstructorI {
                                <br>
                        </p>
                        <p style="text-indent: 25px;">
                            new (arg: number): string
                        </p>
                            <br>
                        <p>
                            }
                                <br>
                                <br>
                            type ResultType1 = CustomInstanceType<ConstructorI> // string
                                <br>
                            type ResultType2 = InstanceType<ConstructorI> // string
                                <br>
                        </p>
                            <br>
                        <h1>
                            Заключение
                        </h1> 
                        <p>
                            TypeScript - это мощный инструмент для разработки, который позволяет улучшить качество вашего кода, сделать его более надежным и легко 
                            поддерживаемым. В этой статье мы рассмотрели более сложные приемы в работе с TypeScript.
                                <br>
                            Не забывайте, что изучение TypeScript - это постоянный процесс, и чем больше вы практикуетесь, тем более уверенно будете использовать его в 
                            своих проектах.
                        </p>
                            <br>
                        <h3>
                            Материалы для изучения
                        </h3>
                            <br>
                        <a class="a1" href="https://habr.com/ru/companies/macloud/articles/559902/">Основы</a>
                            <br>
                        <a class="a1" href="https://www.typescriptlang.org/docs/handbook/utility-types.html">Utility Types</a>
                            <br>
                        <a class="a1" href="https://www.typescriptlang.org/cheatsheets">Шпаргалка по TS в картинках</a>
                        <br>
                        <a class="a1" href="https://habr.com/ru/articles/762902/">TypeScript и все что тебе нужно в разработке</a>
                    </div>
                </div>
            </li>

            <li id="slide2">
                <img class="iphone" src="../img/iphone.jpg" />
                <div class="description">
                    <input type="checkbox" id="show-description-2"/>
                    <label for="show-description-2" class="show-description-label">Подробнее</label>
                    <div class="description-text">
                        <p class="vrcht">
                            Время чтения статьи: 5 минут
                        </p>
                            <br>
                        <h2>
                            17 фишек iOS 17
                        </h2>
                            <br>
                        <h1>
                            Прослушивание веб-страницы в Safari
                        </h1>
                            <br>
                        <p>
                            Для тех кто предпочитает слушать статьи, занимаясь домашними делами, в Safari появилась новая функция, которую 
                            вы бы оценили. Apple теперь предоставляет вам возможность прослушивать веб-страницу, на которой вы находитесь. 
                            Хотя многие веб-сайты уже используют эту функциональность, в Safari это полезное дополнение.
                                <br>
                                <br>
                            Вам просто нужно нажать на опцию AA, расположенную в левой части панели поиска (независимо от того, расположена 
                            ли она внизу экрана или вверху). Во всплывающем окне нажмите на страницу прослушивания, и все готово. 
                            Если вы проведете пальцем вниз, вы получите больше возможностей для управления, таких как пропуск или возврат 
                            назад на 10 секунд и воспроизведение / пауза, но на данный момент вы не можете контролировать скорость чтения.
                                <br>
                                <br>
                        </p>
                            <br>
                        <h1>
                            Интерактивные виджеты
                        </h1>
                            <br>
                        <p>
                            В iOS 16 Apple представила виджеты на главном экране, но они недоступны для действий. Например, если у вас на 
                            главном экране есть музыкальный виджет, вы можете просмотреть воспроизводимую в данный момент песню или нажать 
                            и перейти к Apple Music. С появлением iOS 17 ситуация меняется. Apple добавила больше функциональности виджетам, 
                            чтобы вы могли делать больше одним касанием.
                                <br>
                                <br>
                            Возьмем тот же пример с музыкальным виджетом. Теперь в нем отображается опция воспроизведения / паузы вашей 
                            музыки. Это все еще ограничевает, потому что у вас нет возможности пропустить или вернуться к 
                            трекам, но это лучше, чем ничего. С напоминаниями еще лучше. Теперь вы можете нажимать на определенные 
                            напоминания в виджете, чтобы отметить их как выполненные.
                                <br>
                                <br>
                                    <img class="vidzhet" src="../img/vidzhet.webp">
                                <br>
                            Если у вас есть виджет напоминания в iOS 16, он отображает напоминание, но не позволяет вам что-либо делать с 
                            ним. Если вы нажмете на напоминание, откроется полное приложение напоминаний, в котором вы можете отметить его 
                            завершенным. Для виджета Контакты теперь вы можете напрямую позвонить кому-либо или отправить сообщение одним 
                            нажатием. Идея заключается в том, что вы действительно можете что-то делать с виджетами, даже не отходя от 
                            главного экрана, и это невероятно приятный штрих.
                        </p>
                            <br>
                        <h1>
                            Изменения на главном экране
                        </h1>
                            <br>
                        <p>
                            В iOS 16 всякий раз, когда пытаешься добавить другое приложение в свою социальную папку 
                            (внизу справа на фотографии), оно перемещает папку на следующую страницу. Это происходит каждый раз. 
                            Без исключений. В результате мне нужно переставить значки после добавления приложения в мою папку. Хотя iOS 17 
                            этого не меняет, в новом пользовательском интерфейсе есть опция "Отменить перемещение". Как следует из названия, 
                            это отменяет изменения, внесенные в расположение значков. Чтобы получить опцию "Отмены перемещения", все, что вам 
                            нужно сделать, это встряхнуть iPhone.
                                <br>
                                <br>
                                    <img class="vidzhet" src="../img/vidzhet2.webp">
                                <br>
                            Еще одно изменение заключается в том, что вы получаете новые приложения везде, где находится первое пустое место. 
                            Например, если на второй странице есть пробел, значок недавно установленного приложения появится на этой 
                            странице вместо того, чтобы располагаться на последней странице после всех уже установленных приложений.
                            <br>
                        </p>
                        <h1>
                            Spotlight стал мощнее
                        </h1>
                            <br>
                        <p>
                            Бывают случаи, когда нужно отключить настройку дисплея "True Tone", и для этого нужно открыть приложение 
                            «Настройки», нажать «Дисплей и яркость» и найти "True Tone", чтобы переключить его. В iOS 17 можно провести 
                            пальцем вниз, чтобы вызвать Spotlight, и ввести "True Tone", чтобы перейти на конкретную страницу настроек и 
                            переключить ее, что намного упрощает доступ к ней.
                                <br>
                                <br>
                                    <img class="vidzhet" src="../img/vi.webp">
                                <br>
                            Вы можете ввести "Заметки", и вам будет предложено либо два варианта: открыть приложение Notes для создания новой 
                            заметки, либо значок приложения Notes для удобного доступа к другим заметкам. Если вы видите первый сценарий, 
                            нажмите на второй, и появится небольшое окно для создания заметки. Это очень полезно для записи идей. 
                            Вы также можете получить доступ к определенным ярлыкам Siri из Spotlight.
                            <br>
                        </p>
                        <h1>
                            Новые обои с некоторыми интересными трюками
                        </h1>
                            <br>
                        <p>
                            iOS 17 предоставляет вам доступ к большему количеству обоев. Появились новые обои с астрономией и калейдоскопом. 
                            С другой стороны, Astronomy добавляет все восемь планет на выбор при установке обоев. В iOS 16 при использовании 
                            обоев "Земля" вы получаете эффект анимации при переходе на главный экран – это часть всех обоев "планета" на 
                            iOS 17.
                                <br>
                                <br>
                            Но новые обои - это не самая лучшая часть. iOS 17 позволяет устанавливать соотношение сторон фотографий 4: 3 или 
                            1: 1, при этом они не выглядят странно. Если выбранная вами фотография не помещается на экране блокировки или 
                            увеличена, чтобы соответствовать размеру дисплея, вы можете уменьшить масштаб и вместо этого отобразить черным 
                            цветом те места, которые фотография не закрывает, iOS 17 постепенно цвет по краям становится черным. Это выглядит 
                            более интуитивно понятным и приятным для глаз, чем раньше.
                            <br>
                        </p>
                        <h1>
                            Улучшения автозаполнения
                        </h1>
                            <br>
                        <p>
                            В iOS 16 функция автозаполнения позволяет заполнять коды нажатием кнопки в сообщениях. Программа считывает 
                            одноразовый пароль (OП) и отображает его поверх клавиатуры, с помощью которой можно ввести его в нужном месте. 
                            Но бывают случаи, когда генератор логинов отправляет код на электронную почту вместо сообщения. Если это имеет 
                            место в iOS 16, вам нужно зайти в свое почтовое приложение и скопировать код, чтобы заполнить его в нужном месте.
                                <br>
                                <br>
                            С iOS 17 вам больше не нужно этого делать. Функция автозаполнения распространяется и на приложение Apple Mail, 
                            поэтому вы можете нажать и заполнить OП в верхней части клавиатуры. Еще одним дополнением к автозаполнению 
                            является возможность автоматического удаления проверочных кодов из почты и сообщений, которые делают то, что 
                            следует из названия.
                                <br>
                                <br>
                        </p>
                        <h1>
                            Вы можете повторно использовать старые пароли
                        </h1>
                            <br>
                        <p>
                            Apple вводит возможность использовать предыдущий пароль в течение трех дней. В iOS 17, если вы измените свой 
                            пароль, у вас по-прежнему будет возможность использовать старый в течение 72 часов с момента создания нового.
                                <br>
                                <br>
                            Чтобы воспользоваться этой функцией, нужно открыть приложение "Настройки", коснитесь "Face ID и пароль", и 
                            нажмите срока действия предыдущего пароля сейчас. Это очень полезно в тех редких случаях, когда вы меняете свой 
                            пароль, но требуется некоторое время, чтобы зафиксировать его в вашей голове.
                                <br>
                        </p>
                        <h1>
                            Другие незначительные изменения в iOS 17
                        </h1>
                            <br>
                        <p>
                            iOS 17 добавляет дополнительные функции, которые не нуждаются в подробном описании, но вам может понравиться 
                            знать, что они существуют. Некоторые из них:
                                <br>
                                <br>
                            1. Теперь вы можете настроить разные поисковые системы для стандартных и приватных окон в Safari. Для настройки 
                            перейдите в Настройки > Safari > Частная поисковая система.
                                <br>
                                <br>
                            2. Заметки в iOS 17 позволяют вам связать другую заметку с текущей для лучшего доступа и понимания.
                                <br>
                                <br>
                            3. При увеличении фотографии в правом верхнем углу появляется опция обрезки, чтобы мгновенно получить 
                            отображаемую версию в виде фотографии.
                                <br>
                                <br>
                            4. Если вы удалите пароль из брелка, то теперь хранятся в папке "Недавно удаленные" (внутри пароли в настройках 
                            приложения) в течение 30 дней.
                                <br>
                                <br>
                            5. Центр управления добавляет новый значок Ping My Watch для воспроизведения звукового сигнала на Apple Watch, 
                            когда вам нужно найти, где они лежат.
                                <br>
                                <br>
                            6. Приложение "Лекарства" получает последующие напоминания о тех случаях, когда вам нужно снова напомнить о 
                            приеме лекарства. Чтобы установить его, нужно зайти на здоровье приложения > Лекарства > параметры > 
                            последующие напоминания.
                                <br>
                                <br>
                            7. Увеличенный текст при попытке переместить курсор в iOS 17 становится больше.
                                <br>
                                <br>
                            8. История в Safari теперь отображает значки веб-сайтов для улучшения визуального доступа.
                                <br>
                                <br>
                            9. Новое предупреждение о конфиденциальном контенте, которое размывает конфиденциальные фотографии и видео, 
                            которые вы получаете на свой iPhone.
                        </p>
                    </div>
                </div>
            </li>

            <li id="slide3">
                <img src="../img/verst.jpg" />
                <div class="description">
                    <input type="checkbox" id="show-description-3"/>
                    <label for="show-description-3" class="show-description-label">Подробнее</label>
                    <div class="description-text">
                        <p class="vrcht">
                            Время чтения статьи: 2 минуты
                        </p>
                            <br>
                        <h1>
                            Новые единицы измерения svh, lvh, dvh в CSS для адаптивной верстки
                        </h1> 
                            <br>
                        <p>
                            Рассказываем, зачем нужны новые единицы измерения svh, lvh и dvh в CSS для адаптивной верстки, и чем они 
                            отличаются от прежней единицы vh.
                                <br>
                                <br>
                            Единицы области просмотра были введены в CSS аж в 2012 году, и с тех пор почти ничего в стандартах изменилось. 
                            Для того, чтобы создать адаптивный дизайн, мы использовали единицы измерения vh, vw, vmin, vmax.
                                <br>
                                <br>
                            1. vh (Viewport Height) представляет процент от высоты видимой области (viewport). Например, если установить 
                            свойству height элемента значение 50vh, то этот элемент будет занимать 50% высоты видимой области страницы.
                                <br>
                                <br>
                            2. vw (Viewport Width) представляет процент от ширины видимой области (viewport). Например, если установить 
                            свойству width элемента значение 25vw, то этот элемент будет занимать 25% ширины видимой области страницы.
                                <br>
                                <br>
                            3. vmin (Viewport Minimum) использует наименьшее значение между высотой и шириной видимой области. Например, 
                            если высота видимой области меньше ширины, то 1vmin будет эквивалентно 1% высоты видимой области.
                                <br>
                                <br>
                            4. vmax (Viewport Maximum) использует наибольшее значение между высотой и шириной видимой области. Например, 
                            если высота видимой области больше ширины, то 1vmax будет эквивалентно 1% высоты видимой области.
                                <br>
                                <br>
                            Зато за эти 11 лет сильно изменились интерфейсы: единицы измерения vh, vw, vmin, vmax не учитывали адресные 
                            строки на мобильном устройстве, которые отличаются в разных браузерах.
                                <br>
                                <br>
                            К примеру, в Safari адресная строка располагается внизу окна, а под ней находятся кнопки навигации. В то же 
                            время в мобильной версии Chrome внизу окна располагаются кнопки навигации, а адресная строка висит сверху.
                                <br>
                                <br>
                            Из за этой разницы в интерфейсах возникали трудности в верстке. Если мы используем 100vh, элементы сайта 
                            сверстаются по высоте окна, не учитывая интерфейс браузера.
                                <br>
                                <br>
                            Допустим, вам нужно сверстать кнопку, которая попросит пользователя принять пользовательское соглашение. 
                            Используя vh, вы легко могли попасть в ситуацию, когда ваша кнопка скрывается за поисковой строкой.
                                <br>
                                <br>
                            Чтобы решить эту проблему, в CSS ввели новые единицы измерения. Это svh, lvh и dvh.
                                <br>
                                <br>
                        </p>
                        <h1>
                            Что такое svh, lvh, dvh?
                        </h1>
                            <br>
                        <p>
                            Вот, что значат новые единицы измерения:
                                <br>
                            1. svh представляет высоту области просмотра, когда пользовательский интерфейс адресной строки еще не 
                            уменьшил свой размер. svh отвечает за то содержимое страницы, которое вы будете видеть, когда интерфейс 
                            адресной строки растянут до максимума.
                                <br>
                                <br>
                            2. lvh представляет высоту области просмотра после того, как пользовательский интерфейс адресной строки 
                            уменьшил свой размер. lvh отвечает за то содержимое страницы, когда пользовательский интерфейс сжат до минимума.
                                <br>
                                <br>
                            3. dvh использует любое из значений svh или lvh в зависимости от того, уменьшен ли интерфейс адресной строки. 
                            dvh просчитывает переходные состояния между максимальным и минимальным размером UI в браузере.
                                <br>
                                <br>
                            svh, lvh и dvh поддерживаются всеми распространенными браузерами.
                                <br>
                                <br>
                            Надеемся, svh, lvh и dvh значительно облегчат вашу работу. Если вы уже внедрили новые единицы измерения в свои 
                            продукты, расскажите о впечатлениях!
                        </p>
                    </div>
                </div>
            </li>
            <li id="slide1">
                <img src="" />
                <div class="description">
                    <input type="checkbox" id="show-description-4"/>
                    <label for="show-description-4" class="show-description-label">Подробнее</label>
                    <div class="description-text">
                        <h2></h2>
                        <p></p>
                    </div>
                </div>
            </li>
            <li id="slide5">
                <img src="https://cssdeck.com/uploads/media/items/8/8k3N3EL.jpg" />
                <div class="description">
                    <input type="checkbox" id="show-description-5"/>
                    <label for="show-description-5" class="show-description-label">I</label>
                    <div class="description-text">
                        <h2>Splash!</h2>
                        <p>Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut</p>
                    </div>
                </div>
            </li>
        </ul>
    </div>
</div>

<footer> 
    &copy; 2023 Новостной сайт. Все права защищены. 
</footer> 
</body> 
</html>
